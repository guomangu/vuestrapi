{"version":3,"sources":["webpack://app/./src/service-worker.js"],"names":["async","updateCacheForURL","url","cache","caches","open","cachedResponse","match","response","fetch","put","clone","console","log","importScripts","workbox","setConfig","debug","precaching","precacheAndRoute","self","__WB_MANIFEST","addEventListener","event","data","type","URL","location","origin","waitUntil","routing","registerRoute","RegExp","strategies","NetworkFirst","cacheName","plugins","expiration","ExpirationPlugin","maxAgeSeconds"],"mappings":"YAgCA,eAAe,EAAkB,GAC/B,MAAM,QAAc,OAAO,KAAK,uBAC1B,QAAuB,EAAM,MAAM,GAEzC,GAAI,EAEF,OAIF,MAAM,QAAiB,MAAM,GAC7B,EAAM,IAAI,EAAK,EAAS,QAC1B,CAxCA,QAAQ,IAAI,WAEZ,cAAc,2EAGd,QAAQ,UAAU,CAAE,OAAO,IAG3B,QAAQ,WAAW,iBACjB,yVAAK,eAYP,KAAK,iBAAiB,WAAY,IAChC,GAAwB,gBAApB,EAAM,KAAK,KAAwB,CACrC,MAAM,EAAM,IAAI,IAAI,EAAM,KAAK,IAAK,KAAK,SAAS,QAClD,EAAM,UAAU,EAAkB,GACpC,KAmBA,QAAQ,QAAQ,cACd,IAAI,OAAO,MACX,IAAI,QAAQ,WAAW,aAAa,CAClC,UAAW,sBACX,QAAS,CACP,IAAI,QAAQ,WAAW,iBAAiB,CAEtC,cAAe,aAoFzB,QAAQ,IAAI","file":"service-worker.js","sourceRoot":"","sourcesContent":["// Ce fichier est généré automatiquement par la commande `npx workbox-cli generateSW workbox-config.js`\r\n/* eslint-disable */\r\n/* eslint-disable */ \r\n// Reste du code...\r\nconsole.log(\"goood 1\");\r\n// Importez les bibliothèques de workbox\r\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');\r\n\r\n// Paramétrer le mode debug pour les environnements de développement\r\nworkbox.setConfig({ debug: true });\r\n\r\n// Pré-cache les fichiers statiques\r\nworkbox.precaching.precacheAndRoute(\r\n  self.__WB_MANIFEST,\r\n  // {url: '/manifest.json', revision: '1'},\r\n  );\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nself.addEventListener('message', (event) => {\r\n  if (event.data.type === 'updateCache') {\r\n    const url = new URL(event.data.url, self.location.origin);\r\n    event.waitUntil(updateCacheForURL(url));\r\n  }\r\n});\r\n\r\nasync function updateCacheForURL(url) {\r\n  const cache = await caches.open('dynamic-route-cache');\r\n  const cachedResponse = await cache.match(url);\r\n\r\n  if (cachedResponse) {\r\n    // L'URL est déjà en cache, rien à faire\r\n    return;\r\n  }\r\n\r\n  // L'URL n'est pas en cache, récupérez-la en ligne et mettez-la en cache\r\n  const response = await fetch(url);\r\n  cache.put(url, response.clone());\r\n}\r\n\r\n  \r\n  // Utilisez Workbox pour gérer la stratégie Network First pour les autres routes dynamiques\r\n  workbox.routing.registerRoute(\r\n    new RegExp('.*'),\r\n    new workbox.strategies.NetworkFirst({\r\n      cacheName: 'dynamic-route-cache',\r\n      plugins: [\r\n        new workbox.expiration.ExpirationPlugin({\r\n          // Définissez une durée de mise en cache appropriée selon vos besoins\r\n          maxAgeSeconds: 60 * 60 * 24 * 7,\r\n        }),\r\n      ],\r\n    })\r\n  );\r\n  \r\n\r\n\r\n\r\n  \r\n// self.addEventListener('message', (event) => {\r\n//   if (event.data.type === 'updateCache') {\r\n//     const url = new URL(event.data.url, self.location.origin);\r\n//     event.waitUntil(updateCacheForURL(url));\r\n//   }\r\n// });\r\n\r\n// async function updateCacheForURL(url) {\r\n//   const cache = await caches.open('dynamic-route-cache');\r\n//   const cachedResponse = await cache.match(url);\r\n\r\n//   if (cachedResponse) {\r\n//     // L'URL est déjà en cache, rien à faire\r\n//     return;\r\n//   }\r\n\r\n//   // L'URL n'est pas en cache, récupérez-la en ligne et mettez-la en cache\r\n//   const response = await fetch(url);\r\n//   cache.put(url, response.clone());\r\n// }\r\n\r\n  \r\n\r\n\r\n\r\n\r\n  //============================\r\n  \r\n  // workbox.routing.registerRoute(\r\n  //   ({ url }) => {\r\n  //     const pathMatch = '.*'; // Matches alphanumeric strings with dashes\r\n  //     return pathMatch.test(url.pathname);\r\n  //   },\r\n  //   new workbox.strategies.StaleWhileRevalidate({\r\n  //     cacheName: 'dynamic-route-cache',\r\n  //   })\r\n  // );\r\n\r\n// Cache les pages HTML de navigation avec NetworkFirst strategy\r\n// workbox.routing.registerRoute(\r\n//   ({ request }) => request.mode === 'navigate',\r\n//   new workbox.strategies.StaleWhileRevalidate({\r\n//     cacheName: 'html-cache',\r\n//   })\r\n// );\r\n\r\n\r\n\r\n// workbox.routing.registerRoute(\r\n//   new RegExp('/^\\/[a-zA-Z-]+$/'),\r\n//   async ({ event }) => {\r\n//     const networkFirst = new workbox.strategies.NetworkFirst({\r\n//       cacheName: 'my-cache',\r\n//     });\r\n//     let response;\r\n//     try {\r\n//       response = await networkFirst.handle({ event });\r\n//     } catch (error) {\r\n//       console.log('Network request failed, trying to get response from cache');\r\n//       const cache = await caches.open('my-cache');\r\n//       response = await cache.match(event.request);\r\n//     }\r\n\r\n//     // If response is still null, then we can return a placeholder or fallback page.\r\n//     if (!response) {\r\n//       // return caches.match('offline.html');\r\n//       return;\r\n//     }\r\n\r\n//     return response;\r\n//   }\r\n// );\r\n\r\n\r\nconsole.log(\"goood 2\");"]}